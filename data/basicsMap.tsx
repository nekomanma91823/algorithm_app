export interface BasicsContent {
  name: string;
  description: string;
  features?: string;
  example?: string;
  structure: string;
  pros?: string[];
  cons?: string[];
  realWorldExamples: string[];
  importance?: string;
  nextSteps: string[];
  code?: {
    javascript: string;
    python: string;
  };
  timeComplexity?: {
    best: string;
    average: string;
    worst: string;
  };
  spaceComplexity?: string;
}

export const basicsMap: { [key: string]: BasicsContent } = {
  "cpu-architecture": {
    name: "CPUの仕組み",
    description:
      "コンピュータの中央処理装置（CPU）で、すべての計算や制御を担当する「コンピュータの脳」です。",
    features:
      "プログラムの命令を順次読み取り、実行することでコンピュータ全体を動かします。",
    example:
      "CPUは図書館の司書のような存在です。利用者（プログラム）からの本の貸し出し依頼（命令）を受け取り、本棚（メモリ）から本を見つけて（データ取得）、貸し出し処理（計算）を行い、結果を利用者に渡します。司書が複数の利用者を同時に対応できるように、現代のCPUも複数の処理を並行して実行できます。",
    structure:
      "CPUは主に以下の部分から構成されています。CPUが理解できる命令の種類（言語セットのようなもの）はアーキテクチャごとに決まっています。これを命令セットアーキテクチャ（ISA）と呼び、パソコンで主流の「x86」や、スマートフォンで主流の「ARM」などがあります。：\n1. **制御装置（Control Unit）**: プログラムの命令を解読し、各部分に指示を出す司令塔\n2. **演算装置（ALU: Arithmetic Logic Unit）**: 実際の計算や論理演算を行う計算機\n3. **レジスタ（Register）**: 計算中のデータを一時的に保存する高速メモリ\n4. **キャッシュメモリ**: よく使うデータを保存して高速アクセスを可能にする。通常はCPUに近い順からL1, L2, L3といった階層構造になっており、CPUに近いほど小容量ですが、より高速に動作します。\n5. **クロック**: すべての動作のタイミングを合わせる時計。このクロックが発する信号の速さをクロック周波数（単位: GHz ギガヘルツ）といい、この数値が高いほど、1秒間により多くの処理を行えるため高性能になります。\n**6. 命令パイプライン**: 命令を「取得」「解読」「実行」「保存」といったステージに分け、流れ作業のように並行処理することで、スループットを向上させる仕組み。\n\n処理の流れ：フェッチ（命令取得）→ デコード（命令解読）→ エグゼキュート（実行）→ ライトバック（結果保存）",
    pros: [
      "非常に高速な処理が可能で、すべてのコンピュータ処理の中心となる重要な部品です。",
      "現代のCPUは複数のコア（処理ユニット）を持ち、並列処理により効率的な計算が可能です。",
      "1つのコアで複数の処理の流れ（スレッド）を同時に実行する技術(SMT)もあり、これによりさらなる性能向上が図られています。",
    ],
    cons: [
      "複雑な構造のため製造コストが高く、高性能なCPUほど電力消費が大きく発熱も多くなります。",
      "処理能力には物理的な限界があります。",
    ],
    realWorldExamples: [
      "スマートフォンのプロセッサ",
      "パソコンのCPU（Intel Core、AMD Ryzen）",
      "サーバー用の高性能CPU",
      "組み込みシステム用のマイクロコントローラ",
    ],
    importance:
      "CPUの仕組みを理解することで、プログラムがどのように実行されるか、なぜ効率的なアルゴリズムが重要なのかが分かります。",
    nextSteps: [
      "GPUの仕組みとCPUとの違い",
      "メモリとストレージの階層構造",
      "並列処理とマルチスレッド",
      "キャッシュメモリの最適化",
    ],
  },

  "gpu-architecture": {
    name: "GPUの仕組み",
    description:
      "グラフィックス処理装置（GPU）で、元々は画像処理専用でしたが、現在は並列計算全般に使われる「大量計算の専門家」です。",
    features:
      "数千個の小さな計算ユニットが並列して動作し、同じような計算を大量に同時処理することが得意です。",
    example:
      "GPUは工場の組み立てラインのような存在です。CPUが一人の職人（高性能だが一度に一つの作業）だとすると、GPUは何百人もの作業員が同じ作業を並列して行う工場です。一人一人はそれほど器用ではありませんが、単純な作業を大量に同時処理できるため、全体としては非常に高い生産性を発揮します。",
    structure:
      "GPUは以下の特徴的な構造を持ちます：\n1. **ストリーミングマルチプロセッサ（SM）**: 複数の計算ユニットをまとめた処理ブロック\n2. **CUDA コア/ストリームプロセッサ**: 実際の計算を行う小さな処理ユニット（数千個）\n3. **共有メモリ**: 同じSM内のコア間で高速にデータを共有\n4. **グローバルメモリ**: 大容量だが比較的低速なメモリ領域\n**5. HBM (High Bandwidth Memory)**: GPUに直接統合される超広帯域メモリ。膨大なデータを高速に転送し、GPUの並列処理能力を最大限に引き出します。\n6. **テクスチャメモリ**: 画像処理に最適化された特殊なメモリ\n\n処理方式：SIMD（Single Instruction, Multiple Data）により、同じ命令を複数のデータに並列適用",
    pros: [
      "大量の並列計算で圧倒的な性能を発揮し、機械学習、科学計算、暗号化などの分野で威力を発揮します。画像・動画処理も高速で、ゲームや映像制作に不可欠です。",
    ],
    cons: [
      "逐次処理（順番に実行する処理）は苦手で、複雑な分岐処理がある計算では性能が落ちます。また、プログラミングが複雑で、専用の知識が必要です。",
    ],
    realWorldExamples: [
      "ゲームのグラフィックス処理",
      "機械学習の学習・推論",
      "仮想通貨のマイニング",
      "科学技術計算",
      "動画エンコーディング",
      "3DCG制作",
    ],
    importance:
      "現代のAI・機械学習ブームを支える重要な技術で、大量データ処理の仕組みを理解することで効率的なプログラム設計が可能になります。",
    nextSteps: [
      "CUDA・OpenCLなどの並列計算プラットフォーム",
      "機械学習とGPU計算",
      "メモリ帯域幅と計算効率",
      "CPUとGPUのハイブリッド計算",
    ],
  },

  "memory-and-storage": {
    name: "メモリとストレージ",
    description:
      "コンピュータでデータを保存する仕組みで、速度と容量のバランスによって階層的に構成される「データの住まい」です。",
    features:
      "アクセス速度が速いほど容量が小さく高価になり、容量が大きいほど速度が遅く安価になるという特徴があります。",
    example:
      "メモリとストレージは図書館システムのようなものです。レジスタは司書の手元のメモ（超高速・小容量）、キャッシュは司書の机（高速・小容量）、メインメモリは貸し出しカウンター周辺の本棚（中速・中容量）、ストレージは地下の大型書庫（低速・大容量）に例えられます。よく使う本は手元に、たまに使う本は近くに、滅多に使わない本は書庫に保管する仕組みです。",
    structure:
      "メモリ階層は以下のように構成されます：\n1. **レジスタ**: CPU内の最高速メモリ（数十バイト～数KB）\n2. **L1キャッシュ**: CPU内の一次キャッシュ（数十KB）\n3. **L2/L3キャッシュ**: より大きな二次・三次キャッシュ（数MB）\n4. **メインメモリ（RAM）**: プログラムとデータの作業領域（数GB～数十GB）。**揮発性で電源が切れるとデータは消えます。**\n5. **ストレージ**: 永続的なデータ保存（SSD/HDD）。**不揮発性で電源を切ってもデータは保持されます。**\n**6. ROM (Read-Only Memory)**: 読み取り専用の不揮発性メモリ。コンピュータの起動プログラム（BIOS/UEFI）など、書き換える必要のない重要なデータが保存されます。\n\n各階層間でデータを効率的に移動させることで、全体として高速かつ大容量のシステムを実現",
    pros: [
      "階層化により、高速性と大容量を両立できます。",
      "キャッシュ機能により、よく使うデータへの高速アクセスが可能で、プログラムの実行効率が大幅に向上します。",
    ],
    cons: [
      "複雑な管理が必要で、キャッシュミスが発生すると性能が低下します。",
      "また、揮発性メモリ（RAM）は電源が切れるとデータが消失します。",
    ],
    realWorldExamples: [
      "パソコンのRAMとSSD/HDD",
      "スマートフォンの内蔵ストレージ",
      "サーバーの大容量メモリシステム",
      "データセンターのストレージアレイ",
    ],
    importance:
      "メモリ階層を理解することで、効率的なプログラムの書き方や、データ構造の選択方法が分かり、システム全体のパフォーマンス向上に役立ちます。",
    nextSteps: [
      "キャッシュの最適化技術",
      "仮想メモリとページング",
      "SSDとHDDの仕組みの違い",
      "メモリプールとガベージコレクション",
    ],
  },

  hardware: {
    name: "ハードウェア",
    description:
      "コンピュータを構成する物理的な部品の総称で、触ることができる「コンピュータの身体」です。",
    features:
      "電子回路、機械部品、光学部品などから構成され、ソフトウェアが動作するための物理的な基盤を提供します。",
    example:
      "ハードウェアは人間の身体のようなものです。CPU は脳、メモリは短期記憶、ストレージは長期記憶、マザーボードは神経系統、電源は心臓、冷却ファンは汗腺、入出力デバイスは五感に例えることができます。これらが連携して動作することで、コンピュータという「電子的な生命体」が機能します。",
    structure:
      "主要なハードウェアコンポーネント：\n1. **CPU**: 中央処理装置、計算と制御の中枢\n2. **メモリ（RAM）**: 一時的なデータ保存領域\n3. **ストレージ**: 永続的なデータ保存装置（SSD/HDD）\n4. **マザーボード**: 各部品を接続する基板\n5. **電源ユニット（PSU）**: 電力供給装置\n6. **グラフィックカード（GPU）**: 画像処理専用装置\n7. **入出力デバイス**: キーボード、マウス、ディスプレイなど\n8. **冷却システム**: 熱を逃がすファンやヒートシンク",
    pros: [
      "物理的な処理能力を提供し、高性能なハードウェアにより高速な計算が可能です。",
      "部品の組み合わせにより、用途に応じたカスタマイズができます。",
    ],
    cons: [
      "物理的な劣化や故障が避けられず、性能向上には物理的な限界があります。",
      "また、製造コストが高く、技術の進歩により急速に陳腐化する場合があります。",
    ],
    realWorldExamples: [
      "デスクトップPC",
      "ノートPC",
      "スマートフォン",
      "サーバー",
      "ゲーム機",
      "IoTデバイス",
      "スーパーコンピュータ",
    ],
    importance:
      "ハードウェアの仕組みを理解することで、適切な機器選択、性能のボトルネック特定、効率的なシステム設計が可能になります。",
    nextSteps: [
      "ソフトウェアとの相互作用",
      "組み込みシステムの設計",
      "パフォーマンスチューニング",
      "ハードウェア選択の基準",
    ],
  },

  software: {
    name: "ソフトウェア",
    description:
      "コンピュータに動作を指示するプログラムやデータの総称で、ハードウェアに「魂」を吹き込む存在です。",
    features:
      "プログラミング言語で記述された命令の集合で、ハードウェアを制御してユーザーの要求を実現します。",
    example:
      "ソフトウェアは楽譜のようなものです。ハードウェアがピアノなら、ソフトウェアは楽譜に書かれた音符です。楽譜（プログラム）がなければピアノは音を出せませんし、ピアノ（ハードウェア）がなければ楽譜は音楽になりません。演奏者（CPU）が楽譜を読んで（プログラム実行）、ピアノを弾く（ハードウェア制御）ことで美しい音楽（アプリケーション）が生まれます。",
    structure:
      "ソフトウェアの階層構造：\n1. **ファームウェア**: ハードウェアを直接制御する基本ソフト\n2. **オペレーティングシステム（OS）**: ハードウェアとアプリの仲介役\n3. **ミドルウェア**: OSとアプリケーションの間の支援ソフト\n4. **アプリケーションソフト**: ユーザーが直接使用するソフト\n5. **ドライバソフト**: 特定のハードウェアを制御する専用ソフト\n\nプログラムの実行過程：ソースコード → コンパイル/インタープリット → 機械語 → CPU実行",
    pros: [
      "柔軟性が高く、アップデートや機能拡張が容易です。",
      "同じハードウェアで様々な機能を実現でき、複製コストがほぼゼロで配布できます。",
    ],
    cons: [
      "バグやセキュリティホールが存在する可能性があり、ハードウェアの性能に依存します。",
      "また、複雑化すると保守が困難になる場合があります。",
    ],
    realWorldExamples: [
      "OS（Windows、macOS、Linux）",
      "Webブラウザ",
      "Word/Excel",
      "ゲーム",
      "スマートフォンアプリ",
      "Webサイト",
      "人工知能システム",
    ],
    importance:
      "ソフトウェアの概念を理解することで、プログラミングの本質、システム設計の考え方、効率的な開発手法が身につきます。",
    nextSteps: [
      "プログラミング言語の選択",
      "ソフトウェア開発ライフサイクル",
      "アルゴリズムとデータ構造",
      "ソフトウェアアーキテクチャ",
    ],
  },

  "os-role": {
    name: "OSの役割",
    description:
      "オペレーティングシステム（OS）は、ハードウェアとアプリケーションの間に立つ「仲裁者・管理者」です。",
    features:
      "ハードウェアリソースの管理、プロセス制御、ファイル管理、ユーザーインターフェースの提供など、コンピュータの基本的な動作を支えます。",
    example:
      "OSはホテルの支配人のような存在です。客室（メモリ）の割り当て、レストラン（CPU）の席の案内、荷物預かり（ファイルシステム）、設備（ハードウェア）の管理、お客様（アプリケーション）のリクエスト処理など、ホテル全体の運営を統括します。お客様は支配人を通じてホテルのサービスを利用し、支配人がいないとホテルは機能しません。",
    structure:
      "OSの主要な機能と構成：\n1. **プロセス管理**: プログラムの実行制御とスケジューリング\n2. **メモリ管理**: 物理メモリの割り当てと仮想メモリの実現\n3. **ファイルシステム**: ファイルとディレクトリの管理\n4. **入出力管理**: デバイスドライバーを通じたハードウェア制御\n5. **ネットワーク管理**: 通信プロトコルとネットワーク接続\n6. **ユーザーインターフェース**: GUI/CLIを通じたユーザー操作\n7. **セキュリティ**: アクセス制御と権限管理\n8. **システムコール**: アプリケーションからOSサービスへのインターフェース",
    pros: [
      "ハードウェアの複雑さを隠蔽し、アプリケーション開発を簡単にします。",
      "複数のプログラムを同時実行でき、リソースの効率的な利用が可能です。",
    ],
    cons: [
      "OSが複雑になると動作が重くなり、OSのバグが全体に影響します。",
      "また、ハードウェアの性能を100%活用できない場合があります。",
    ],
    realWorldExamples: [
      "Windows（PC）、macOS（Mac）、Linux（サーバー・組み込み）、Android/iOS（スマートフォン）、リアルタイムOS（産業機器）など",
    ],
    importance:
      "OSの役割を理解することで、プログラムがどのように動作するか、システムの性能問題の原因、効率的なソフトウェア設計が分かります。",
    nextSteps: [
      "プロセスとスレッドの詳細",
      "メモリ管理の仕組み",
      "ファイルシステムの種類",
      "カーネルとユーザーモード",
    ],
  },

  "process-thread": {
    name: "プロセスとスレッド",
    description:
      "実行中のプログラムを管理する単位で、プロセスは「独立した作業部屋」、スレッドは「部屋内の作業員」です。",
    features:
      "プロセスは独立したメモリ空間を持ち、スレッドはプロセス内でメモリを共有して並行動作します。",
    example:
      "プロセスとスレッドは会社の組織のようなものです。プロセスは独立した部署（営業部、開発部など）で、それぞれ専用のオフィス（メモリ空間）と予算（リソース）を持ちます。スレッドは部署内の社員で、同じオフィスを共有しながら異なる作業を並行して行います。部署間のやり取り（プロセス間通信）は正式な手続きが必要ですが、同じ部署の社員同士（スレッド間）は簡単に情報共有できます。",
    structure:
      "プロセスとスレッドの構造：\n**プロセス（Process）**:\n1. **プロセスID（PID）**: OSが割り当てる一意な識別番号\n2. **独立メモリ空間**: コード、データ、ヒープ、スタック領域\n3. **リソース管理**: ファイル、ネットワーク接続などの管理\n4. **プロセス制御ブロック（PCB）**: プロセスの状態情報\n\n**スレッド（Thread）**:\n1. **スレッドID**: プロセス内での識別番号\n2. **共有メモリ**: プロセスのメモリ空間を共有\n3. **独立スタック**: 各スレッド専用のスタック領域\n4. **実行コンテキスト**: レジスタ値、プログラムカウンタ\n\n状態遷移：新規 → 実行可能 → 実行中 → 待機 → 終了",
    pros: [
      "並行処理により処理速度が向上し、CPUを効率的に活用できます。",
      "マルチタスクにより複数の作業を同時進行でき、ユーザビリティが向上します。",
    ],
    cons: [
      "競合状態（レースコンディション）やデッドロックが発生する可能性があり、デバッグが複雑になります。",
      "また、コンテキストスイッチのオーバーヘッドが発生します。",
    ],
    realWorldExamples: [
      "Webブラウザの複数タブ（プロセス）",
      "動画再生中の他作業（スレッド）",
      "Webサーバーのリクエスト処理",
      "ゲームの描画・音響・入力処理など",
    ],
    importance:
      "現代のマルチコアCPUを活用するために必須の概念で、効率的な並行プログラミングの基礎となります。",
    nextSteps: [
      "並行性と並列性の違い",
      "同期プリミティブ（mutex、semaphore）",
      "プロセス間通信（IPC）",
      "非同期プログラミング",
    ],
  },

  "memory-management": {
    name: "メモリ管理",
    description:
      "コンピュータのメモリリソースを効率的に配分・管理する仕組みで、「メモリという限られた資源の管理者」です。",
    features:
      "プログラムに必要なメモリを動的に割り当て、不要になったメモリを回収し、メモリを効率的に利用するための様々な技術を提供します。",
    example:
      "メモリ管理は図書館の座席管理システムのようなものです。利用者（プログラム）が来ると空いている席（メモリ領域）を案内し、利用が終わったら席を片付けて次の利用者のために準備します。満席の時は仮想的な席（仮想メモリ）を作り、一時的に書庫（ストレージ）に荷物を預けて（スワップ）空きを作ります。利用者が席を散らかしたまま帰ってしまう（メモリリーク）と、使える席が減ってしまうため、定期的な清掃（ガベージコレクション）が必要です。",
    structure:
      "メモリ管理の主要技術：\n1. **動的メモリ割り当て**: malloc/free、new/deleteによる実行時メモリ確保\n2. **仮想メモリ**: 物理メモリより大きなアドレス空間の提供\n3. **ページング**: メモリを固定サイズのページに分割して管理\n4. **スワッピング**: 使用頻度の低いデータをストレージに退避\n5. **ガベージコレクション**: 不要になったメモリの自動回収\n6. **メモリプール**: 事前確保したメモリ領域の再利用\n7. **セグメンテーション**: プログラムの論理的な分割管理\n8. **MMU（Memory Management Unit）**: ハードウェアレベルでの仮想-物理アドレス変換",
    pros: [
      "限られたメモリを効率的に活用でき、プログラムが物理メモリ量を意識せずに動作できます。",
      "メモリ保護により他のプログラムのメモリを破壊することを防げます。",
    ],
    cons: [
      "管理のオーバーヘッドが発生し、メモリ断片化や仮想メモリのページフォルトによる性能低下が起こる場合があります。",
      "メモリリークのリスクもあります。",
    ],
    realWorldExamples: [
      "JavaやPythonの自動メモリ管理",
      "C/C++の手動メモリ管理",
      "OSの仮想メモリシステム",
      "データベースのバッファプール管理",
    ],
    importance:
      "メモリ効率の良いプログラム作成、メモリリークの回避、システムパフォーマンスの最適化に不可欠な知識です。",
    nextSteps: [
      "ガベージコレクションアルゴリズム",
      "メモリプールとアロケータ設計",
      "NUMA（Non-Uniform Memory Access）",
      "メモリ最適化技術",
    ],
  },

  "logical-operations": {
    name: "論理演算",
    description:
      "真（True）と偽（False）の値を使った計算で、コンピュータの判断や条件分岐の「思考の基礎」です。",
    features:
      "**AND、OR、NOT、XORなどの基本演算を組み合わせて複雑な条件判定や制御を行います。多くの言語では、結果が確定した時点で評価を打ち切る「短絡評価」が採用されており、効率的な処理に寄与します。**",
    example:
      "論理演算は日常の意思決定のようなものです。「雨が降っている AND 傘を持っている」なら外出する、「お金がある OR クレジットカードがある」なら買い物できる、「NOT 忙しい」なら映画を見る、といった判断です。信号機も論理演算の例で、「赤でない AND 歩行者用信号が青」なら渡れる、という複数条件の組み合わせで動作します。",
    structure:
      "基本的な論理演算：\n1. **AND（論理積）**: 両方が真の時のみ真\n   - True AND True = True\n   - その他はすべてFalse\n\n2. **OR（論理和）**: どちらかが真なら真\n   - False OR False = False\n   - その他はすべてTrue\n\n3. **NOT（否定）**: 真偽を反転\n   - NOT True = False\n   - NOT False = True\n\n4. **XOR（排他的論理和）**: どちらか一方だけが真の時に真\n   - True XOR False = True\n   - False XOR True = True\n   - 同じ値同士はFalse\n\n5. **NAND、NOR**: ANDとORの否定版\n\n真理値表により全ての組み合わせパターンを定義",
    pros: [
      "シンプルで理解しやすく、複雑な条件も基本演算の組み合わせで表現できます。",
      "コンピュータの電子回路とも対応しており、高速な処理が可能です。",
    ],
    cons: [
      "複雑な条件になると読みにくくなり、論理の組み合わせミスによるバグが発生しやすくなります。",
    ],
    realWorldExamples: [
      "プログラムのif文、データベースのWHERE句、検索エンジンのクエリ、電子回路の論理ゲート、セキュリティのアクセス制御など",
    ],
    importance:
      "プログラミングの条件分岐、アルゴリズムの設計、データベース検索、システム設計における必須の基礎知識です。",
    nextSteps: [
      "ド・モルガンの法則",
      "カルノー図による論理簡単化",
      "ビット演算との関係",
      "ブール代数と論理回路",
    ],
  },

  "number-systems": {
    name: "2進数と16進数",
    description:
      "コンピュータが内部で使用する数の表現方法で、10進数以外の「コンピュータの言語」です。",
    features:
      "2進数は0と1だけを使い、16進数は0-9とA-Fを使ってデータを効率的に表現します。",
    example:
      "数の表現は異なる言語のようなものです。同じ数でも、日本語で「十二」、英語で「twelve」、ローマ数字で「XII」と表現が違います。同様に、数字の「12」は10進数で「12」、2進数で「1100」、16進数で「C」と表現されます。内容は同じでも、表記方法が違うだけです。コンピュータは電気のON/OFF（2進数）で動作するため、2進数が自然な表現になります。",
    structure:
      "各進数の仕組み：\n\n**2進数（Binary）**:\n- 基数：2（0と1のみ使用）\n- 位の重み：...、8、4、2、1\n- 例：1101₂ = 1×8 + 1×4 + 0×2 + 1×1 = 13₁₀\n\n**16進数（Hexadecimal）**:\n- 基数：16（0-9、A-F使用）\n- A=10、B=11、C=12、D=13、E=14、F=15\n- 例：2A₁₆ = 2×16 + 10×1 = 42₁₀\n\n**変換方法**:\n- 10進→2進：2で割り続けて余りを下から読む\n- 2進→10進：各桁に位の重みを掛けて合計\n- 2進↔16進：4ビットずつまとめて変換（2⁴=16）",
    pros: [
      "コンピュータの内部動作を理解でき、メモリアドレスやビット演算が直感的に分かります。",
      "16進数は2進数よりもコンパクトで読みやすい表現です。",
    ],
    cons: [
      "慣れるまで計算が難しく、人間にとっては10進数より直感的でありません。",
      "大きな数になると桁数が多くなります。",
    ],
    realWorldExamples: [
      "メモリアドレス（0x1000）",
      "カラーコード（#FF0000）",
      "ファイルの16進ダンプ",
      "プロセッサの命令コード",
      "ネットワークのMACアドレスなど",
    ],
    importance:
      "プログラミング、システム開発、デバッグ、セキュリティ分析など、コンピュータサイエンスの基礎として不可欠です。",
    nextSteps: [
      "ビット演算（AND、OR、XOR、シフト）",
      "浮動小数点数の表現（IEEE 754）",
      "文字コード（ASCII、Unicode）",
      "データ型とメモリサイズ",
    ],
  },

  "set-theory": {
    name: "集合",
    description:
      "同じ性質を持つ要素をまとめたもので、データベース、アルゴリズム、プログラミングの「分類と整理の基礎」です。",
    features:
      "要素の包含関係、集合同士の演算（和、積、差）、重複を許さない一意性などの特徴があります。",
    example:
      "集合は仲間グループのようなものです。「野球部の生徒」「バスケ部の生徒」「両方に所属する生徒（積集合）」「どちらかに所属する生徒（和集合）」「野球部だけの生徒（差集合）」といった具合に、グループの関係を整理できます。図書館の本も「小説の集合」「SF小説の集合」「日本のSF小説の集合」のように、より具体的な集合に分類できます。",
    structure:
      "集合の基本概念と演算：\n\n**基本概念**:\n- **要素（Element）**: 集合に含まれる個々の項目\n- **部分集合（Subset）**: A ⊆ B（AのすべてがBに含まれる）\n- **空集合（Empty Set）**: 要素が一つもない集合 ∅\n- **全体集合（Universal Set）**: 考察対象のすべてを含む集合\n\n**集合演算**:\n1. **和集合（Union）**: A ∪ B（AまたはBに含まれる要素）\n2. **積集合（Intersection）**: A ∩ B（AかつBに含まれる要素）\n3. **差集合（Difference）**: A - B（AにあるがBにない要素）\n4. **補集合（Complement）**: A'（全体集合でAに含まれない要素）\n\n**ベン図**: 集合の関係を視覚的に表現する図式",
    pros: [
      "論理的思考を整理でき、複雑な条件や関係を明確に表現できます。",
      "データベースやアルゴリズムの設計で重要な概念です。",
    ],
    cons: [
      "抽象的で理解に時間がかかる場合があり、実装時には効率性を考慮する必要があります。",
    ],
    realWorldExamples: [
      "データベースのJOIN操作",
      "検索エンジンのフィルタリング",
      "プログラミングの配列操作",
      "機械学習の特徴選択",
      "アクセス権限の管理など",
    ],
    importance:
      "論理的思考、データ構造の設計、アルゴリズムの理解、データベース操作の基礎として重要です。",
    nextSteps: [
      "関数と写像",
      "順序関係と同値関係",
      "集合を使ったアルゴリズム",
      "データベースの関係代数",
    ],
  },

  complexity: {
    name: "計算量",
    description:
      "アルゴリズムの効率性を測る尺度で、プログラムがどれくらいの時間やメモリを使うかを予測する「性能の通知表」です。",
    features:
      "時間計算量（実行時間）と空間計算量（メモリ使用量）があり、入力サイズに対してどのように増加するかをビッグO記法で表現します。",
    example:
      "計算量は料理のレシピの効率性のようなものです。1人分の料理を作るレシピ（O(1)）、人数に比例して材料が増えるレシピ（O(n)）、人数の2乗で手間が増える複雑なレシピ（O(n²)）があります。100人分の料理を作る時、O(1)なら1人分と同じ手間、O(n)なら100倍、O(n²)なら10,000倍の手間がかかります。良いレシピ（効率的なアルゴリズム）ほど、人数が増えても手間が爆発的に増えません。",
    structure:
      "計算量の主要な分類：\n\n**時間計算量（Time Complexity）**:\n- **O(1)**: 定数時間（配列の要素アクセス）\n- **O(log n)**: 対数時間（二分探索）\n- **O(n)**: 線形時間（配列の全走査）\n- **O(n log n)**: 線形対数時間（高効率ソート）\n- **O(n²)**: 二次時間（二重ループ）\n- **O(2ⁿ)**: 指数時間（全組み合わせ探索）\n\n**空間計算量（Space Complexity）**:\n- 入力に対して必要なメモリ量\n- 一時的な作業領域も含む\n\n**最悪・平均・最良時間**:\n- 最悪時間：最も時間がかかるケース\n- 平均時間：一般的なケースの期待値\n- 最良時間：最も早く終わるケース",
    pros: [
      "アルゴリズムの性能を客観的に比較でき、大規模データでの動作を予測できます。",
      "実装前に効率性を検討でき、適切なアルゴリズム選択が可能です。",
    ],
    cons: [
      "実際の実行時間は定数係数や実装の詳細に依存し、理論値と実測値が異なる場合があります。",
      "また、小さなデータでは効率の差が分からないことがあります。",
    ],
    realWorldExamples: [
      "Googleの検索エンジン",
      "データベースのインデックス",
      "画像認識AI",
      "ゲームの物理シミュレーション",
      "暗号化アルゴリズム",
      "リアルタイム通信システムなど",
    ],
    importance:
      "効率的なプログラム設計、適切なアルゴリズム選択、スケーラブルなシステム構築のための基礎知識として不可欠です。",
    nextSteps: [
      "具体的なアルゴリズムの計算量分析",
      "データ構造の選択基準",
      "アルゴリズムの最適化技法",
      "実装とベンチマーク測定",
    ],
  },
};
